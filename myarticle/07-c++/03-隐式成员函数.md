C++自动提供：

* 默认构造函数，如果没有定义构造函数的话
* 拷贝构造函数，如果没有定义
* 赋值操作符，如果没有定义
* 默认析构函数，如果没有定义
* 地址操作符，如果没有定义

## 拷贝构造函数(复制构造函数)

假设有一个类A，复制构造函数的原型为

```C++
A(const A&);
```

以下的几种写法都会调用复制构造函数：

A aa(a)

A aa = a

A aa = A(a)

A *aa = new A(a);

默认的复制构造函数会逐个复制**非静态**成员(也称**浅拷贝**)，复制是的成员的值，如果成员本身也是一个类对象，那么递归使用这个类的复制构造函数。如果成员是一个指针，那么复制的仅仅是地址而已。

这种浅拷贝有时会导致问题，比如，我在Class A的构造函数里面new了一个对象：

char* str = new char[len+1];

那么显然我应该在析构函数里释放它：

delete []str;

但是假如这中间调用了拷贝构造函数:  `A  b = a;`,那么str的地址传给对象b，但是str已经在a的析构里面释放了。

解决这个问题，你应该显式定义拷贝构造函数，复制str（而不是地址）。这个过程叫做**深拷贝**。此外你还要考虑赋值操作带来的同样问题。

## 赋值操作符

C++自动为类重载赋值操作符，class A的原型为：

```C++
A & A::operator=(const A &);
```

赋值操作符的隐式实现也是逐个复制成员，这点与拷贝构造函数类似。当成员本身就是类对象时，递归调用那个类的赋值操作符来复制。静态成员是不受影响的。

所以前面提到的浅拷贝导致的问题，这里仍然存在。解决方法也是一样的，显式提供赋值操作符重载，但是代码比显式拷贝构造函数复杂一点。结合代码来说明：

```C++
A & A::operator=(const A & a){
    if(this == &a){//因为赋值的语法是允许赋给自己的，所以你要先判断一下是不是一个对象。拷贝构造函数不需要考虑
        return *this;
    }
    //this对象的str字段已经在构造函数里分配过数据了，要先删除再分配新的数据。拷贝构造函数不需要考虑这点
    delete[] str;
    str = new char[len+1];
    std::strcpy(str, a.str);
    return *this;//返回自身，这样才能支持连续赋值 a = b = c
}
```



下面的代码会使用赋值操作符：

aa = a;

但是`A aa = a;`调用的是拷贝构造函数，相当于`A aa(a);`。不过也有编译器把这一步分解为两步：

A temp(a);

aa = temp;

也就是先创建一个临时变量，然后通过赋值操作符赋给aa。

