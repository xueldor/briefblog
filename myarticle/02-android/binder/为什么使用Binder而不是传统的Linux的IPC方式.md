### Linux现有的所有进程间IPC方式：

- 管道：在创建时分配一个page大小的内存，缓存区大小比较有限；
- 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；
- 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；
- 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；
- 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；

首先安卓是用到上面这些IPC机制的，尤其是本地套接字，用的很多。Zygote进程与APP的IPC采用的是Socket，设置系统属性也是使用通过本地socket发送给init进程；Kill Process采用的signal（信号）机制；但是上层App之间的IPC交互、system_server进程与上层App的交互，主要还是用的自家独特的binder机制。原因如下：

1）从性能角度

管道、消息队列、Socket都需要两次数据拷贝，Binder数据拷贝只需要一次，性能更好；共享内存倒是一次拷贝都不需要，性能更佳，但是写共享内存完成后怎么通知对方是个问题。

2）从稳定性角度

Binder是基于C/S架构，server端和client端相对独立，稳定性较好；而共享内存实现方式比较复杂，没有客户端和服务端的区别，需要充分考虑到临界资源的并发同步问题，否则可能会出现死锁；稳定性上Binder是优于共享内存。

3）从安全角度

* 传统的Linux IPC方式无法获得对方进程可靠的UID/PID, 依赖对方自己把UID/PID填入到数据包中，所以无法确切地鉴别对方的身份；而Android为每个安装好的应用都分配了自己的UID，可靠的身份标记由IPC机制本身在内核中增加，client发送数据到server端的时候，server端就会根据权限控制策略判断UID/PID是否满足权限。
* 传统IPC访问接入点是开放的，无法建立私有通道。从安全角度，Binder的安全性更高。

4）从语言层面角度

Binder符合面向对象的思想，将进程间通信转化为通过Binder对象调用该对象的方法。可以把Binder对象视为一个可以跨进程引用的对象，它的实体位于一个进程中，而它的引用却遍布于系统的各个进程之中。Binder模糊了进程边界，淡化了进程间通信过程，仿佛是在一个进程中调用。

并且binder可以在native层使用，也可以在java层使用；通过aidl使开发十分简单。

