### 内部类和嵌套类

```java
//这是java
class Outer {

    class Inner {
        //内部类，持有外部类的应用
    }

    static class Nested {
        //嵌套类，不持有外部类
    }
}
```

Java中内部类会持有外部类引用，这层引用关系通常很容易忽略而造成内存泄露和意料之外的问题。因此Kotlin中**默认是嵌套类**

如果想声明成内部类，需要使用`inner` 修饰符：

```kotlin
class Outer {
    //内部类, 需要加inner
    inner class Inner {
        fun getOuter(): Outer = this@Outer//this@Outer,又是一个与java不一样的地方
    }
    //嵌套类，不需要加static
    class Nested {
        //不持有外部类
    }
}
```

在Java中内部类通过`Outer.this` 来获取外部类的对象，而在Kotlin中则是通过`this@Outer` 获得外部类对象。

### 密封类

`sealed` 修饰符限制**子类**必须**嵌套**在父类中(Kotlin1.1解除了一些限制，只要子类与密封类在一个文件中)

```kotlin
sealed class Father {
    class ChildA : Father()

    class ChildB : Father()
}
```

密封类可以防止你的父类被别人随意继承。

密封类看做是枚举的拓展，基于枚举，高于枚举

### 构造方法

Kotlin相对java做了一点修改：区分了主构造方法和从构造方法。

#### 主构造方法和初始化语句块

示例1：

```kotlin
//简洁写法
class User (val nickName: String){
    init{
        println("xx $nickName")
    }
}

//<=======等价------>
class User constructor(_nickName: String) {//少了val
    val nickName: String//如果用简洁写法，则这一行是自动生成的

    init {
        nickName = _nickName//如果用简洁写法，则这一行是自动生成的
        println("xx $nickName")
    }
}
//--如果还有疑惑，把上面两种写法分别反编译成java， 看一眼就明白了。
```

1. 类名后面跟“constructor(参数)”定义主构造方法
2. 如果没有其他修饰符（比如private），则constructor可以省略,直接写括号。
3. `nickName: String`参数前面加上val，定义构造函数的参数的同时，给类声明了属性，并自动生成赋值。是一种简洁写法。
4. init{xxx}称为`初始化语句块`,也是当你执行主构造函数时执行的代码块。
5. `class User{xxx}`表示不主动提供主构造方法,编译器会判断要不要帮你隐式生成一个无参的。

#### 从构造方法

尽量用**默认参数**来避免写太多的构造方法。但是如果你一定要声明多个构造参数，也是可以的：

```kotlin
open class View {
    constructor(context: Context)
    constructor(context: Context):this()//wrong，根本没有这个构造函数
    constructor(context: Context, attributes: Attributes)
} 
```

如果提供了主构造方法，那么从构造方法必须**直接或间接**调用主构造方法。间接的意思是，通过另外一个从构造方法，间接的执行到主构造。

上面的例子第二个构造器为什么错呢？根据我的分析，这里面规则和java一样的，如果你一个构造器都没有提供(不管主还是从)，但是创建对象时，总归需要一个构造器吧，所以编译器帮你创建了一个无参构造器。但是一旦你写了从构造器，编译器就不会帮你创建默认的无参构造器了，所以这个地方其实没有this()这个方法。

如果你这么写：

```kotlin
open class View() {//如果后面加括号，即显式地提供构造函数
    constructor(context: Context)//错
    constructor(context: Context):this()//right
}
```

第一个constructor为什么报错？因为View后面加括号你就提供了主构造器，那么从构造器必须调用主构造器。

由此可见，如果没有参数，你给它写个括号，纯属没事找事。

### 类继承

示例一：

```kotlin
open class User
class Friend : User//wrong，因为User类有一个默认的没有参数的构造函数
class Friend : User()//right，Friend类有一个默认的无参构造，里面调用User()
class Friend(): User()//right,Friend()里调用User()
//
```

示例二：

```kotlin
open class User{
    constructor(name: String)
}
class Friend: User()//wrong,没有User()这个构造函数
```

示例三：

```kotlin
open class User
//if 这样
class Friend: User{//这段代码是OK的，对比示例一，想想区别在哪？
    constructor(isSquare: Boolean){
    }
}

//如果这样
class Friend: User(){//错，子类没有主构造器，如何调父类构造函数？
    constructor(isSquare: Boolean){
    }
}

//and 如果这样
class Friend(): User(){
    constructor(isSquare: Boolean){//错，这里必须调用主构造器
    }
}

//and 如果这样
class Friend(): User{//错，friend()里面会调用父类的构造器，所以User要加括号
}

//and 如果这样
class Friend(): User(){
    constructor(isSquare: Boolean):super(){//还是提示调用主构造器
    }
}
//接上，but 如果这样
class Friend: User{
    constructor(isSquare: Boolean):super(){//OK了，因为已经没有主构造器了，直接调用super即父类构造
    }
    constructor(isSquare: Boolean)//把super()删了也行，因为父类User的构造函数本来就没有参数，方法内会自动默认调用super()
}
```

示例四：

```kotlin
open class User{
    constructor(name: String)
}
class Friend(name: String,age:Int): User(name)
//OK, Friend的构造函数里调用User(name),把name参数传给User.
```

示例五：

```kotlin
open class User{
    constructor(name: String)
}
class Friend: User("aa"){//right
}
```

也许示例看的稀里糊涂，咱们总结一下：

1. 如果有主构造器，则从构造器一定要显式地指定调用的主构造器，方法是冒号后面this(xxx)

2. 如果没有主构造器，则从构造器可以用super(xxx)指定调用的父类构造方法。如果不写，系统会默认调用父类无参构造方法。所以，当父类没有无参构造时，你必须用super(xxx)明确。

3. class Child (xxx) ： Father(xxx)的原理是，Child (xxx)明确了子类的主构造方法，学过java的都知道，子类的构造方法里面必须调用父类的某个构造方法。所以后面的Father括号不能丢，必须用括号指定执行父类的哪个构造()

4. class Child： Father,Father通常没有括号，因为加括号就等于要调用Father的构造方法，但是没有定义Child的主构造，Father的构造方法由谁来调用呢？而示例五Father必须要有括号,因为Child没有定义从构造，于是系统有一个默认的无参构造，里面会掉Father("xxx"),一旦Father没有无参构造，就会报错。

   可能还是很绕人，其实原理很简单，理清楚了就简单了。理不清楚也没关系，IDE会有报错的提示。

### 数据类

即`data class` 声明的类, 一种快速简单声明java bean的方式。

```kotlin
data class Stu(val name: String)
```

反编译成java，你会发现kotlin为data class复写了toString` 、`equals` 及`hashCode三个方法。比如toString是这样：

```java
//反编译成java
@NotNull
public String toString() {
   return "Stu(name=" + this.name + ")";
}
```

对于`data class `,前面还介绍过`解构声明`,可以去复习一下。

### 类委托

一个类需要实现某接口，发现有一个对于这个接口已经实现好的类，可以直接将这个现成的类拿来使用，只有部分方法需要自己实现。于是就可以将实现委托给这个`现成的类`的对象。其思想类似设计模式里的`装饰器模式`。

```kotlin
class DelegatingCollection<T>(val innerList: Collection<T> = ArrayList<T>()
) : Collection<T> by innerList
DelegatingCollection实现了Collection接口，把对接口的实现委托给innerList。只需要重写我们需要改变行为的方法就可以了。
```

### 属性委托

```kotlin
class BASE {
    var x: Int by MY();
    /* 
		等价于 var x$MY = MY()
				get() = x$MY.getValue(this, BASE::x)
				set(value) = x$MY.setValue(this, BASE:x, value);
	*/
    var y: Int by MY();
}
```

### object关键字