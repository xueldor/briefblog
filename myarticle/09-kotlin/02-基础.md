主要还是说说跟java中不一样的部分。

### 顶层函数

**思想：**Java中有静态函数和静态属性概念，在外部访问的直接利用**类名.方法名**访问。在Kotlin中则认为一个函数或方法有时候并不是属于任何一个类，它可以独立存在。

**语法：** 一个函数或者属性，直接定义在一个Kotlin文件的顶层中。在使用的地方只需要import这个函数或属性即可。"Util"后缀结尾的工具类，是时候去掉了。

**原理：**通过反编译成java，可以总结出两点内容

1、顶层文件会反编译成一个容器类。(类名一般默认就是顶层文件名+"Kt"后缀，注意容器类名可以自定义)
2、顶层函数会反编译成一个static静态函数

在**文件顶部**,在**package声明**的前面,通过Kotlin中的@file: JvmName(“自定义生成类名”)注解,可以自动生成对应Java调用类名

```kotlin
@file: JvmName("FormateUtil")
package com.ymc.kotlindemo

import java.math.BigDecimal

fun formateFileSize(size: Double): String { ... }
```



#### Java中如何调用Kotlin中的顶层函数

反编译生成的类作为静态函数容器类, 直接调用对应的函数

```java
System.out.println("文件大小: " + FormateFileKt.formateFileSize(1111));// Java中调用Kotlin中定义顶层函数，一般是顶层文件名+"Kt"后缀作为静态函数的类名调用相应函数
```

### 顶层属性

和 顶层函数 相似，属性也是可以放在文件的顶层

### 扩展函数

定义函数时，在函数名前面加上类或者接口名称，中间用“.”连接：

```kotlin
// 扩展String类，添加一个lastData函数
fun String.lastData() : Char{
    return this.get(this.length-1)
}

// 获取最后一个单词
import util.lastData
println("Kotlin".lastData())
```

当成员函数与扩展函数，名字、参数都一样时，**成员函数优先级高**。

扩展函数 并不算是类的一部分，他是声明在类之外的，编译成java字节码后，毕竟真实的类里面是没有这些方法的。这些方法对应对应Java中的静态函数，第一个参数为接收者类型的对象。所以 **扩展函数是不可以 继承的**。

### 扩展属性

扩展属性也没有真的为该类添加了属性，只能说是为该类通过get、set方法计算出属性。换言之，你只是加了get\set方法，没有真实的存在内存中的字段，因此没有幕后字段（filed），你的set方法不能给field赋值，只能给其它真正存在的字段赋值。并且也不能初始化。

`val` 属性不可变，因此只需要定义getter，而`var` 属性可变，所以getter和setter都需要。 

```kotlin
//尝试给String扩展一个test属性
var String.test : Char = 'a'//错，没有幕后字段，不能初始化

var String.test : Char
     set(value)  {
         //field = value 错，扩展属性并没有真正添加属性也就没有field
         setCharAt(length - 1, value)
     }
     get() {
         return 'a'
     }
```

### 可变参数

看个例子

```kotlin
val strings = listOf("first", "second", "fourteenth")
//listOf 函数的定义
public fun <T> listOf(vararg elements: T): List<T>
//等同于java的：
public <T> List<T> listOf(T... elements)//java
```

`vararg` 关键字，让函数支持任意个数的参数。

跟java的区别：java中可变参数就是数组，可以按原样传递数组，数组中每个元素自动作为参数。

而Kotlin把数组整体当做一个参数，所以你需要显示地解包数组，这个功能被称为**展开运算符**：

```kotlin
val array = arrayOf("a", "b")
val list = listOf("c", array)
println(list)//输出: [c, [Ljava.lang.String;@5305068a]

val list2 = listOf<String>("c", *array)//加一个星号
println(list2)//[c, a, b]

```

### 中缀调用

```kotlin
val map = mapOf(1 to "one", 7 to "seven", 52 to "fifty-five")
val x = 1 until 10
```

`to` 和`until`并不是一个内置的结构，而是一种特殊的函数调用，被称为中缀调用。以下两种调用方式是等价的：

```kotlin
1.to("one")//普通调用
1 to "one" //中缀调用
```

**条件1：**函数只有一个参数

**条件2：**使用`infix` 修饰符来标记它

例如`to` 函数的声明：

```kotlin
public infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)
```

这里引入一个Pair类。Pair是Kotlin标准库中的类，它是用来表示一对元素。

### 解构声明

```kotlin
val (number, name) = 1 to "one"
```

这个功能称之为解构声明，`1 to "one"` 会返回一个Pair对象，Pair包含一对元素，也就是1和one，接着又定义了变量`(number, name)` 分别指向Pair中的1和one。 

解构声明实际上就是将对象中所有属性，解构成一组属性变量。举个例子，

```kotlin
//声明一个数据类
data class Student(var name: String, var age: Int, var grade: Double)
//-----使用
val student = Student("mikyou", 18, 99.0)
val (name, age, grade) = student//将一个student对象解构成一组3个单独的变量
println("my name is $name , I'm $age years old, I get $grade score")//解构后的3个变量可以脱离对象，直接单独使用

//也可以 部分解构
val (_, age, grade) = student//下划线_ 忽略name属性

```

解构声明的对象类型一定是data class。比如上面说的Pair类，在kotlin lib中的声明如下：

```kotlin
public data class Pair<out A, out B>(
    public val first: A,
    public val second: B
) : Serializable {
    public override fun toString(): String = "($first, $second)"
}
```

### var、val、const val区别

var:  

```kotlin
var mAge: Int = 0
//生成一个private的字段和public的get和set：
private I mAge
public final getMAge()I
public final setMAge(I)V

//既然是对外不暴露的，也就不会生成get和set
private var mAge: Int = 0
```

val ：

跟var的区别是，不会生成set、多了final修饰符。因为是只读的。

```kotlin
val mAge: Int = 0
//---->to java
private final I mAge = 0
public final getMAge()I
```

const val: 

```kotlin
//首先，const val只能用在顶层属性、最外部的object、伴生对象上面。
const val mAge: Int = 0
//---》to java
public final static I mAge = 0
```

可见const val完全相当于java中的public static final 。外面直接访问属性而不是通过get。

### 自动类型转换

```kotlin
if (obj is String) {
    // 做过类型判断以后，obj会被系统自动转换为String类型
    return obj.length
}
//等价的java代码：
if (obj instanceof String) {
    return ((String)obj).length
}

```

另外还支持 “!is”:

```kotlin
if (usr !is User){
  // XXX
}
```

### 参数的默认值

```kotlin
class User @JvmOverloads constructor(val nickName: String, val isSubscribed: Boolean = true)
```

在User类的构造函数里，参数isSubscribed我们给了默认值true。通过这种方法，有效减少了定义重载构造。